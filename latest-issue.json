[{"body":"\n**Description:**\n\nReact's `useEffect` hook relies on the equality check of dependencies array to determine whether to re-run the effect.  However, when dealing with objects as dependencies, a common pitfall arises leading to unnecessary re-renders.  Even if the object's contents haven't changed, a simple assignment `myObject = {...myObject}` creates a new object reference, triggering the effect.  This can severely impact performance, especially with large objects or frequent updates.\n\n**Example:**\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [myObject, setMyObject] = useState({ name: 'John', age: 30 });\n\n  useEffect(() => {\n    console.log('Effect running!'); // Runs more often than expected\n    // ... perform some expensive operation based on myObject ...\n  }, [myObject]);\n\n  const updateAge = () => {\n    setMyObject({ ...myObject, age: myObject.age + 1 }); // Creates a new object reference\n  };\n\n  return (\n    <div>\n      <p>Name: {myObject.name}</p>\n      <p>Age: {myObject.age}</p>\n      <button onClick={updateAge}>Increment Age</button>\n    </div>\n  );\n}\n```\n\nIn this example, even though only the `age` property changes, the `useEffect` hook re-runs because `myObject` is a new object reference after each call to `updateAge`.\n\n**Proposed Solutions:**\n\n* **Use `useMemo` to memoize the object:** This can prevent unnecessary object creation if the object's content hasn't changed.\n\n```javascript\nconst memoizedObject = useMemo(() => myObject, [myObject]);\nuseEffect(() => {\n  console.log('Effect running!');\n}, [memoizedObject]);\n```\n\n* **Shallow comparison using `useRef`:**  For simpler objects, `useRef` can hold the object's state and enable direct comparison.  This avoids creating new references.\n\n* **Use a library like `immer`:**  `immer` provides a more elegant way to update objects immutably, preventing the creation of new object references.\n\n\n**Suggested Improvements:**\n\n* Could we improve the React documentation to clearly explain this common issue and provide clear guidance on how to effectively manage object dependencies in `useEffect`?\n* Should the React team consider introducing a feature to automatically handle shallow comparisons for object dependencies in `useEffect` (perhaps an optional flag)?\n\n\n**Severity:** Medium to High (depending on the complexity of the application and the frequency of the unnecessary re-renders).  This can lead to performance degradation and unexpected behaviour.\n","number":54,"title":"## Issue: Unexpected Re-renders due to Object Comparison in `useEffect` Hook"}]
