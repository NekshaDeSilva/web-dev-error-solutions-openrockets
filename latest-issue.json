[{"body":"\n## Description of the Error\n\nA common issue in Next.js Middleware is incorrectly handling the `not-found` response.  Middleware functions can redirect or rewrite requests, but if you don't handle a 404 (Not Found) scenario explicitly, your users might see a generic error page instead of a custom 404 page you designed.  This is particularly problematic if your middleware is attempting to rewrite URLs based on conditions which might not always be met.  If the condition fails, the middleware will implicitly pass through, possibly leading to a 404 if the resulting URL doesn't exist.\n\n\n## Step-by-Step Code Fix\n\nLet's imagine we have middleware that attempts to redirect `/blog/:slug` URLs to a specific CMS-based URL. If the slug doesn't exist in the CMS, we should return a 404 instead of a generic error.\n\n**Incorrect Middleware (Will lead to a generic 404):**\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(req) {\n  const slug = req.nextUrl.pathname.replace('/blog/', '');\n\n  // Simulate fetching data from a CMS - this could fail\n  const blogPost = fetchBlogPost(slug);  // Assume this function sometimes returns null\n\n  if (blogPost) {\n    return NextResponse.rewrite(new URL(`/blog-post/${blogPost.id}`, req.url))\n  }\n  // Missing 404 handling here!\n}\n\nexport const config = {\n  matcher: '/blog/:slug*'\n}\n\n\n//Helper function - simulating an API call that might fail\nconst fetchBlogPost = async (slug) => {\n  // Simulate a failed API call \n  if(slug === 'nonexistent-post') return null;\n  return {id: slug} //Simulate successful fetch\n}\n```\n\n**Corrected Middleware (Handles 404):**\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server'\n\nexport async function middleware(req) {\n  const slug = req.nextUrl.pathname.replace('/blog/', '');\n\n  const blogPost = await fetchBlogPost(slug);\n\n  if (blogPost) {\n    return NextResponse.rewrite(new URL(`/blog-post/${blogPost.id}`, req.url));\n  } else {\n    return new NextResponse(null, { status: 404 });\n  }\n}\n\nexport const config = {\n  matcher: '/blog/:slug*'\n};\n\n\n//Helper function - simulating an API call that might fail\nconst fetchBlogPost = async (slug) => {\n  // Simulate a failed API call \n  if(slug === 'nonexistent-post') return null;\n  await new Promise(resolve => setTimeout(resolve, 500));//Simulate API call delay\n  return {id: slug} //Simulate successful fetch\n}\n```\n\nThis corrected version explicitly returns a `NextResponse` with a `status` of 404 when `fetchBlogPost` returns `null`, ensuring a proper 404 response is sent.\n\n\n## Explanation\n\nThe crucial change is adding an `else` block to explicitly handle the case where `blogPost` is null (or undefined, depending on your `fetchBlogPost` implementation).  Without this explicit handling, the middleware silently passes through, and Next.js attempts to handle the request, likely resulting in a generic 404 error.  By returning a `NextResponse` with a `404` status code, you ensure that Next.js knows to serve your custom 404 page (if you have one configured), providing a much better user experience.  Using `async/await` ensures proper handling of asynchronous API calls.\n\n\n## External References\n\n* **Next.js Middleware Documentation:** [https://nextjs.org/docs/app/building-your-application/routing/middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware)\n* **NextResponse API:** [https://nextjs.org/docs/api-reference/next/server#nextresponse](https://nextjs.org/docs/api-reference/next/server#nextresponse)\n\n\nCopyrights (c) OpenRockets Open-source Network. Free to use, copy, share, edit or publish.\n","number":1130,"title":"Next.js Middleware: Handling the `not-found` Response Properly"}]
